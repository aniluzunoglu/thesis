{{
  "language": "Solidity",
  "sources": {
    "contracts/Daoclub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n\n\npragma solidity >=0.4.22 <0.9.0;\n\n\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\n\n\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract Daoclub is ReentrancyGuard, IERC20 {\n    \n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n\n   // ISwapRouter public swapRouter;\n\n    \n    /* erc20 param */\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    /* erc20 param */\n\n    /*遍历成员*/\n    mapping(address => bool) private _inserted;\n    address[] public _members;\n\n    //todo 如何获取合约的所有代币\n    //address[] public _tokenContracts;\n\n    /* daoclub param */\n    address private _owner;\n    address private _summonerAddress;\n    bool private _initialized;\n    uint256 public _initTimestamp;\n    uint8 public _daoStatus; //0: Fundraising,1: Fundraising completed operation,2: Liquidation in progress,3: Liquidation completed\n    \n    mapping(address => uint8) public _voteResult; //（0未投票 1yes 2no）\n    uint256 public _yesShares;\n    uint256 public _noShares;\n    uint256 public _gasFeeLimit;\n    uint8 public _liquidationPeriod;\n    \n    uint256 public _totalFund;\n    uint256 public _actualFund;\n    uint256 public _miniOffering;\n    uint256 public _amountOfGrandTotalLiquidation;\n    uint8 private _managementFee;\n    uint8 private _profitDistribution;\n    uint256 private _periodTimestamp;\n    uint256 private _duration;\n    string public _targetSymbol;  //ETH/USDT/USDC\n    IERC20 public _targetToken;\n    //IWETH9 private _targetWeth;\n    uint256 public _receivableManagementFee;\n    bool public _receivedManagementFee;\n    \n    \n    /* daoclub param */\n\n\n    /***********\n    EVENT\n    ***********/\n    event BuyToken(address indexed buyer, uint256 amount);\n    event FundraisingCompleted();\n    event SubmitProposal(address indexed daoAddress, address indexed Submitter);\n    event SubmitVote(address indexed daoAddress, address indexed voter, uint8 vote, uint256 shares);\n    event ProposalSucceeded(address indexed daoAddress, address voter);\n    event ProposalFailed(address indexed daoAddress, address voter);\n    event LiquidationCompleted(address indexed daoAddress, address memberAddress, uint256 amount, uint256 totalAmount);\n\n\n    /********\n    MODIFIERS\n    ********/\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    modifier onlyMember {\n        require(_balances[msg.sender] > 0, \"Daoclub ::onlyMember - not a member\");\n        _;\n    }\n\n    modifier onlyGpAndLp {\n        require(_balances[msg.sender] > 0 || _owner == msg.sender, \"Daoclub :: onlyGpAndLp\");\n        _;\n    }\n\n    modifier possibleToByToken {\n        require(daoStatus() == 0, \"Daoclub Can not buy: status error\");\n        require(block.timestamp < _periodTimestamp, \"Daoclub Can not buy: Time has expired\");\n        require(getBalance() <= _totalFund, \"Daoclub Can not buy: enough to raise\");\n        _;\n    }\n\n    receive() external payable {\n    }\n\n\n    fallback() external payable {\n    }\n\n    function daoStatus() public view returns(uint8 daoStatus_) {\n        if(_daoStatus == 0 && block.timestamp > _periodTimestamp) {\n            daoStatus_ = 1;\n        }else {\n            daoStatus_ = _daoStatus;\n        }\n    }\n\n    /**测试完了记得删除**/\n    // function resetInitTimeStamp(uint256 initTimestamp) external {\n    //     _initTimestamp = initTimestamp;\n    // }\n\n\n    function init(\n        address summoner,\n        string memory tokenSymbol,\n        uint256 totalSupply_,\n        uint256 totalFund,\n        uint256 miniOffering,\n        uint8  managementFee,\n        uint8  profitDistribution,\n        uint256  periodTimestamp,\n        uint256  duration,\n        address summonerAddress,\n        string memory targetSymbol\n    ) external {\n        require(_initialized == false, \"Daoclub: cannot be initialized repeatedly \");\n        _initialized = true;\n        _owner = summoner;\n        _daoStatus = 0;\n        _name = tokenSymbol;\n        _symbol = tokenSymbol;\n        _miniOffering = miniOffering;\n        _managementFee = managementFee;\n        _profitDistribution = profitDistribution;\n        _totalFund = totalFund;\n        //铸币\n        _mint(address(this), totalSupply_);\n        _targetSymbol = targetSymbol;\n        if (compareStr(targetSymbol, \"USDT\")) {\n            //0xB61d1dB83E6478e3daDf22caEb79D1ceC613ab0e\n            _targetToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7); //USDT主网合约地址0xdAC17F958D2ee523a2206206994597C13D831ec7 测试地址0xB61d1dB83E6478e3daDf22caEb79D1ceC613ab0e\n        } else if(compareStr(targetSymbol, \"USDC\")) {\n            _targetToken = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);  //USDC合约地址\n        } else {\n            //_targetToken = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);  //WETH合约地址 rinnkby 0xDf032Bc4B9dC2782Bb09352007D4C57B75160B15\n            //_targetWeth = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);   //WETH合约地址 rinnkby 0xDf032Bc4B9dC2782Bb09352007D4C57B75160B15\n        }\n        _periodTimestamp = periodTimestamp;\n        _duration = duration;\n        _summonerAddress = summonerAddress;\n        _initTimestamp = block.timestamp;\n        //swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); //SwapRouter合约地址\n    }\n    \n\n\n    function withdraw(uint256 amount) onlyOwner external {\n        require(daoStatus() == 1, \"Daoclub: Can only be withdrawn after the fundraising is completed\");\n        require(amount <= getBalance(), \"Daoclub: The withdrawal amount cannot be greater than the dao balance\");\n        //burn \n        fundraisingCompleted();\n\n        if(isETH()) {\n            payable(_summonerAddress).transfer(amount);\n        }else {\n            _targetToken.safeTransfer(_summonerAddress, amount);\n        }\n    }\n\n\n\n    function buyTokenByETH() possibleToByToken external payable {\n        require(isETH(), \"Daoclub: target token is not ETH\");\n        require(address(this).balance <= _totalFund, \"Can not buy: enough to raise\");\n        require(daoStatus() == 0, \"Daoclub: status can not buy\");\n        require(msg.value >= _miniOffering, \"Daoclub: miniOffering are not met\");\n        _actualFund += msg.value;\n        //send token\n        _transfer(address(this), msg.sender, _totalSupply.mul(msg.value).div(_totalFund));\n\n        emit BuyToken(msg.sender, msg.value);\n        \n        fundraisingCompleted();\n    }\n\n\n    function buyTokenByUSDTorUSDC(uint256 amount) possibleToByToken external {\n        require(!isETH(), \"Daoclub: target token is ETH\");\n        require(_targetToken.balanceOf(address(this)) + amount <= _totalFund, \"Can not buy: enough to raise\");\n        require(daoStatus() == 0, \"Daoclub: status can not buy\");\n        require(amount >= _miniOffering, \"Daoclub: miniOffering are not met\");\n        \n        \n        \n        \n        \n        //_targetToken.transferFrom(msg.sender, address(this), amount); \n        _targetToken.safeTransferFrom(msg.sender, address(this), amount);\n        \n        _actualFund += amount;\n        \n        //send token\n        _transfer(address(this), msg.sender, _totalSupply.mul(amount).div(_totalFund));\n        \n\n        emit BuyToken(msg.sender, amount);\n    \n        fundraisingCompleted();\n    }\n\n    //募集结束\n    function fundraisingCompleted() onlyGpAndLp public {\n        if(block.timestamp > _periodTimestamp || _actualFund == _totalFund || _totalFund.sub(_actualFund) < _miniOffering) {\n            _daoStatus = 1;\n            //销毁剩余代币\n            if(balanceOf(address(this)) > 0) {\n                _burn(address(this), balanceOf(address(this)));\n            }\n            emit FundraisingCompleted();\n        }\n    }\n\n\n\n    //发起提案\n    function submitProposal(uint256 gasFeeLimit, uint8 liquidationPeriod) onlyGpAndLp external {\n        fundraisingCompleted();\n        require(daoStatus() == 1, \" Proposal not allowed in current status \");\n        _daoStatus = 2;\n        _yesShares = 0;\n        _noShares = 0;\n        _gasFeeLimit = gasFeeLimit;\n        _liquidationPeriod = liquidationPeriod;\n        for(uint i = 0; i < _members.length; i++ ) {\n            _voteResult[_members[i]] = 0;\n        }\n        emit SubmitProposal(address(this), msg.sender);\n    }\n\n\n    //提交投票\n    function submitVote(uint8 vote) onlyMember external {\n        require(daoStatus()== 2, \"no Proposal\");\n        //判断是否投过票\n        if(_voteResult[msg.sender] == 0) {\n            //没投过\n            _voteResult[msg.sender] = vote;\n            if(vote == 1) {\n                _voteYes();\n            }else {\n                _voteNo();\n            }    \n        }else {\n            require(_voteResult[msg.sender] != vote, \"Can't vote again\");\n            if(_voteResult[msg.sender] == 1) {\n                _yesShares -= _balances[msg.sender];\n                _voteNo();\n            }else {\n                _noShares -= _balances[msg.sender];\n                _voteYes();\n            }\n        }\n        \n        emit SubmitVote(address(this), msg.sender, vote, _balances[msg.sender].mul(100).div(_totalSupply));\n\n    }\n\n    function _voteYes() internal { \n        _yesShares += _balances[msg.sender];\n        if(_yesShares >= _totalSupply.mul(7).div(10)) {\n            //投票成功 ， 触发清算， xx时间之后 自动清算 但是我不能在这sleep啊\n            //状态变更 投票通过\n            _daoStatus = 3;\n            //计算应收管理费\n            //首先计算管理天数\n            uint256 managementDays_ = block.timestamp.sub(_initTimestamp).div(24 * 3600);\n            if(managementDays_ > _duration) {\n                managementDays_ = _duration;\n            }\n            _receivableManagementFee = _actualFund.mul(_managementFee).div(36500).mul(managementDays_);\n            _receivedManagementFee = false;\n            \n\n            emit ProposalSucceeded(address(this), msg.sender);\n        }\n    }\n\n    function _voteNo() internal {\n        _noShares += _balances[msg.sender];\n        if(_noShares >= _totalSupply.mul(3).div(10)) {\n            //本次提案失败，DAO状态回退\n            _daoStatus = 1;\n            emit ProposalFailed(address(this), msg.sender);\n        }\n    }\n\n    \n\n\n    function isETH() internal view returns(bool) {\n        return compareStr(_targetSymbol, \"ETH\");\n    }\n\n\n    // function sellToken() internal returns (uint256 amountOut){\n    //     //合约中的币 怎么获取 如果能获取\n    //     //遍历目标币合约\n    //     for(uint8 i = 0; i< _tokenContracts.length; i++) {\n    //         //通过UNISWAP卖出币收回targetSymbol;\n    //         // 将资产授权给 swapRouter\n    //         TransferHelper.safeApprove(_tokenContracts[i], address(swapRouter), IERC20(_tokenContracts[i]).balanceOf(address(this)));\n    //         // amountOutMinimum 在生产环境下应该使用 oracle 或者其他数据来源获取其值\n    //         ISwapRouter.ExactInputSingleParams memory params =\n    //             ISwapRouter.ExactInputSingleParams({\n    //                 tokenIn: _tokenContracts[i],\n    //                 tokenOut: address(_targetToken),\n    //                 fee: 3000,\n    //                 recipient: address(this),\n    //                 deadline: block.timestamp,\n    //                 amountIn: IERC20(_tokenContracts[i]).balanceOf(address(this)),\n    //                 amountOutMinimum: 0,\n    //                 sqrtPriceLimitX96: 0\n    //             });\n\n    //         amountOut = swapRouter.exactInputSingle(params);\n\n    //     }\n    //     if(isETH()) {\n    //         //把weth拆封变成eth\n    //         _targetWeth.withdraw(_targetToken.balanceOf(address(this)));\n    //     }\n        \n\n    // }\n\n    \n    //清算\n    function liquidate() onlyGpAndLp external {\n        require(daoStatus() == 3, \"Daoclub: yes shares less than 70%\");\n        //获取结算资金\n        uint256 amountOfThisLiquidation_ = getBalance();\n        if(!_receivedManagementFee) {    \n            require(amountOfThisLiquidation_ > _receivableManagementFee, \"Daoclub: Insufficient amount\");\n            if(isETH()) {\n                payable(_summonerAddress).transfer(_receivableManagementFee);\n            }else {\n                _targetToken.safeTransfer( _summonerAddress, _receivableManagementFee);\n            }\n            _receivedManagementFee = true;\n            amountOfThisLiquidation_ = amountOfThisLiquidation_.sub(_receivableManagementFee);\n\n        }\n\n        //先来一波卖币逻辑\n        //sellToken();\n\n        \n        uint256 gpProfit_ = 0;\n        if((amountOfThisLiquidation_ + _amountOfGrandTotalLiquidation) > _actualFund) {\n            //分利润\n            uint256 profit_;\n            if(_amountOfGrandTotalLiquidation < _actualFund) {\n                profit_ = amountOfThisLiquidation_ + _amountOfGrandTotalLiquidation - _actualFund;\n            }else {\n                profit_ = amountOfThisLiquidation_;\n            }\n            //先分gp\n            gpProfit_ = profit_.mul(_profitDistribution).div(100);\n            if(isETH()) {\n                payable(_summonerAddress).transfer(gpProfit_);\n            }else {\n                _targetToken.safeTransfer( _summonerAddress, gpProfit_);\n            }\n            amountOfThisLiquidation_ -= gpProfit_;\n            //emit LiquidationCompleted(address(this), _owner, gpProfit_, _fundShare());\n        }\n        for(uint i = 0; i < _members.length; i++ ) {\n            if(_balances[_members[i]] > 0) {\n                uint256 distributeProfit_ = amountOfThisLiquidation_.mul(_balances[_members[i]]).div(_totalSupply);\n                if(isETH()) {\n                    payable(_members[i]).transfer(distributeProfit_);\n                }else {\n                    _targetToken.safeTransfer(_members[i], distributeProfit_);\n                }\n                emit LiquidationCompleted(address(this), _members[i], distributeProfit_, _fundShare(_members[i]));\n            }\n        }\n        _amountOfGrandTotalLiquidation = _amountOfGrandTotalLiquidation + amountOfThisLiquidation_ + gpProfit_;\n        \n\n        \n    }\n\n\n\n    function getBalance() public view returns (uint256) {\n        if(isETH()) {\n            return address(this).balance;\n        }else {\n            return _targetToken.balanceOf(address(this));\n        }\n    }\n\n\n\n    \n    /* erc20 function */\n    function name() public view virtual  returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual  returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual  returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    \n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(daoStatus() == 0 || daoStatus() == 1, \"The current DAO state cannot be traded\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n        if(!_inserted[to]) {\n            _inserted[to] = true;\n            _members.push(to);\n        }\n            \n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        if(!_inserted[account]) {\n            _inserted[account] = true;\n            _members.push(account);\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    \n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    \n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    \n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /* erc20 function */\n\n\n\n    /* util function */\n\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function compareStr(string memory _str, string memory str) public pure returns (bool) {\n        return keccak256(abi.encodePacked(_str)) == keccak256(abi.encodePacked(str));\n    }\n\n    function _checkOwner() internal view virtual {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function _fundShare(address member) internal view returns (uint256) {\n        return _actualFund.mul(_balances[member]).div(_totalSupply);\n    }\n\n    \n\n    /* util function */\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n}\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\ncontract CloneFactory { // implementation of eip-1167 - see https://eips.ethereum.org/EIPS/eip-1167\n    function createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\ncontract DaoclubSummoner is CloneFactory { \n    \n    address public _template;\n    address _owner;\n    Daoclub private _daoclub; // daoclub contract\n    address[] public _summonedDaoclub;\n    uint public _daoIdx = 0;\n    \n    constructor(address template) {\n        _template = payable(template);\n        _owner = msg.sender;\n    }\n    \n    event SummonComplete(address indexed daoclub, address summoner);\n    \n\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function resetTemplate(address template) onlyOwner external {\n        _template = payable(template);\n    }\n    \n     \n    function summonDaoclub(\n        address summoner,\n        string memory tokenSymbol,\n        uint256 totalSupply,\n        uint256 totalFund,\n        uint256 miniOffering,\n        uint8  managementFee,\n        uint8  profitDistribution,\n        uint256  periodTimestamp,\n        uint256  duration,\n        address summonerAddress,\n        string memory targetSymbol\n    ) public returns (address) {\n        _daoclub = Daoclub(payable(createClone(_template)));\n        _daoclub.init(\n            summoner,\n            tokenSymbol,\n            totalSupply,\n            totalFund,\n            miniOffering,\n            managementFee,\n            profitDistribution,\n            periodTimestamp,\n            duration,\n            summonerAddress,\n            targetSymbol\n        );\n        _summonedDaoclub.push(address(_daoclub));\n        _daoIdx ++;\n       \n        emit SummonComplete(address(_daoclub), summoner);\n        return address(_daoclub);\n    }\n    \n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}
